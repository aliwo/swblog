# 종만북에서 풀었던 문제. 삼각형 모양만 다르다.
# cache[i][j] 보다 f 스트링을 사용한 1중 dict 가 훨씬 빠르다.
# 이게 반복으로 풀 수 있는 문제인가?

cache = {}


def move(triangle, i, j):
    '''
    현재 위치에서 내려갔을 떄 얻을 수 있는 최댓값을 반환합니다.
    '''
    print('재귀')
    key = f'{i} {j}'

    if key in cache:
        return cache[key]

    if i > len(triangle) - 1:
        return 0

    if j > len(triangle[i]) - 1:
        return 0

    cache[key] = triangle[i][j] + max(move(triangle, i + 1, j), move(triangle, i + 1, j + 1))

    return cache[key]


def solution2(triangle):
    return move(triangle, 0, 0)

'''
정확성  테스트
테스트 1 〉	통과 (0.06ms, 10.9MB)
테스트 2 〉	통과 (0.09ms, 10.8MB)
테스트 3 〉	통과 (0.17ms, 10.8MB)
테스트 4 〉	통과 (0.56ms, 10.8MB)
테스트 5 〉	통과 (3.93ms, 11.5MB)
테스트 6 〉	통과 (1.14ms, 10.9MB)
테스트 7 〉	통과 (4.01ms, 11.5MB)
테스트 8 〉	통과 (0.92ms, 11MB)
테스트 9 〉	통과 (0.07ms, 10.8MB)
테스트 10 〉	통과 (0.57ms, 10.8MB)
효율성  테스트
테스트 1 〉	통과 (135.51ms, 87MB)
테스트 2 〉	통과 (101.01ms, 69.9MB)
테스트 3 〉	통과 (151.49ms, 97.7MB)
테스트 4 〉	통과 (131.07ms, 88.2MB)
테스트 5 〉	통과 (126.83ms, 82.7MB)
테스트 6 〉	통과 (156.39ms, 100MB)
테스트 7 〉	통과 (144.33ms, 93.4MB)
테스트 8 〉	통과 (121.79ms, 78.9MB)
테스트 9 〉	통과 (127.00ms, 83MB)
테스트 10 〉	통과 (148.24ms, 95.3MB)
'''


# 단 한 줄 짜리 lambda 솔루션
solution = lambda t, l = []: max(l) if not t else solution(t[1:], [max(x,y)+z for x,y,z in zip([0]+l, l+[0], t[0])])

# 매 번 리스트를 잘라내는 데도 미친듯이 빠르다. 심지어 뒷 부분이 아니라 앞부분을 잘라내는데!
# 재귀호출도, 리스트 절삭도 쓰지 않는 솔루션보다도 더 빠르다.
# 재귀호출을 쓰지 않는 것도 아니다.
#


'''
정확성  테스트
테스트 1 〉	통과 (0.05ms, 10.8MB)
테스트 2 〉	통과 (0.06ms, 10.7MB)
테스트 3 〉	통과 (0.09ms, 10.7MB)
테스트 4 〉	통과 (0.17ms, 10.7MB)
테스트 5 〉	통과 (0.90ms, 11.3MB)
테스트 6 〉	통과 (0.31ms, 10.8MB)
테스트 7 〉	통과 (0.84ms, 11.2MB)
테스트 8 〉	통과 (0.29ms, 10.9MB)
테스트 9 〉	통과 (0.06ms, 10.8MB)
테스트 10 〉	통과 (0.17ms, 10.7MB)
효율성  테스트
테스트 1 〉	통과 (24.20ms, 87MB)
테스트 2 〉	통과 (20.48ms, 69.8MB)
테스트 3 〉	통과 (31.22ms, 97.8MB)
테스트 4 〉	통과 (26.18ms, 88.1MB)
테스트 5 〉	통과 (25.30ms, 82.7MB)
테스트 6 〉	통과 (30.91ms, 100MB)
테스트 7 〉	통과 (28.93ms, 93.4MB)
테스트 8 〉	통과 (24.44ms, 78.9MB)
테스트 9 〉	통과 (25.28ms, 83MB)
테스트 10 〉	통과 (29.77ms, 95.3MB)
'''

# 한 줄 짜리 솔루션 해석
def solution(t, l = []):
    '''
    맨 위에서 맨 아래로. 딱 n 번 회전한다.
    하지만 매번 리스트를 새로 만듦으로 n^2 + n / 2 만큼의 시간복잡도
    삼각형을 녹여버리는 방법은 삼각형의 밑바닥 부분을 많이 회전.
    하지만 람다식은 삼각형의 윗 부분을 많이 회전.
    윗 부분이 훨씬 작으므로 람다식이 유리하다.
    '''
    print('람다!')
    if not t:  # 탈출 조건. 삼각형을 전부 소모한다.
        return max(l)
    result = []
    for x, y, z in  zip([0]+l, l+[0], t[0]): # [0] + l = 0 더하기 리스트
        # zip 은 리스트를 n 개 받아서 각 리스트 마다 foreach 를 돌아줘요
        # for a, b, c in zip(A, B, C) 이면 a 는 A의 요소, b 는 B의 요소, c 는 C의 요소
        result.append(max(x, y) + z) # result 에 하나씩 더함

    return solution(t[1:], result) # t[1:] 은 리스트 t의 0번째 요소를 절삭한 리스트

'''
정확성  테스트
테스트 1 〉	통과 (0.05ms, 10.8MB)
테스트 2 〉	통과 (0.06ms, 10.7MB)
테스트 3 〉	통과 (0.08ms, 10.8MB)
테스트 4 〉	통과 (0.18ms, 10.8MB)
테스트 5 〉	통과 (1.01ms, 11.3MB)
테스트 6 〉	통과 (0.33ms, 10.8MB)
테스트 7 〉	통과 (1.02ms, 11.2MB)
테스트 8 〉	통과 (0.27ms, 10.9MB)
테스트 9 〉	통과 (0.05ms, 10.6MB)
테스트 10 〉	통과 (0.16ms, 10.7MB)
효율성  테스트
테스트 1 〉	통과 (29.81ms, 86.9MB)
테스트 2 〉	통과 (23.10ms, 69.8MB)
테스트 3 〉	통과 (33.76ms, 97.7MB)
테스트 4 〉	통과 (31.58ms, 88.1MB)
테스트 5 〉	통과 (27.68ms, 82.7MB)
테스트 6 〉	통과 (35.42ms, 100MB)
테스트 7 〉	통과 (31.94ms, 93.4MB)
테스트 8 〉	통과 (26.13ms, 79MB)
테스트 9 〉	통과 (28.01ms, 82.9MB)
테스트 10 〉	통과 (32.73ms, 95.3MB)
'''

def solution(triangle):
    '''
    삼각형의 맨 위부터 녹여가면서 푸는 방식
    바로 위의 Int 값을 그 아래의 요소들에게 합산한다.
    2 중 for 문을 돌기 때문에 n(n-1) 즉, n^2 의 시간 복잡도.

    DP 가 아니라 탐욕법으로 풀었다. 심지어 DP 보다 빠르다.
    '''
    for t in range(1, len(triangle)):
        for i in range(t+1):
            if i == 0:
                triangle[t][0] += triangle[t-1][0]
            elif i == t:
                triangle[t][-1] += triangle[t-1][-1]
            else:
                triangle[t][i] += max(triangle[t-1][i-1], triangle[t-1][i])
    return max(triangle[-1])


solution([[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]])
solution2([[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]])

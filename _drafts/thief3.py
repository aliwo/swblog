# 2019-10-18 드디어 해결
# 문제 해결의 키 포인트:
# 하향식 (재귀호출) DP 일 경우
#
# 1. 턴 집과 안 턴집의 모든 상태를 기록한다면 (DFS의 노드 순회 처럼)
#  동적 계획법으로 메모이제이션 하는 의미가 없어집니다.
#  중복을 피하면서, 모든 집을 효율적으로 순회하는 방법이 필요한데
#  0번쨰 집 부터 시계방향으로만 순회하면 된다는 것을 깨달아야 합니다.
#  또한 함수의 인자로는 start 와 end 만 넘겨주어야 합니다.
#
# 2. 하향식 재귀호출로는 효율성 테스트를 하나도 통과하지 못합니다.
#  1번을 깨닫고 모든 정확성 테스트를 통과하는 함수를 만들었지만, 효율성테스트는 0점을 맞더라구요.
#  재귀호출의 overhead 때문으로 여겨집니다. 상향식 DP 를 생활하도록 합시다.
#
# 3. 0번째 집을 터느냐 안 터느냐 때문에 경우의 수가 나뉘기 때문에 end 를 바꿔주어야 하고
#  새로운 end 때문에 메모이제이션도 2번 해야 됩니다. 비효율적이죠.
#
# 상향식 (반복) DP 일 경우
#
# 1. 하향식일때는 f(start, end) = start 부터 end 까지 되는대로 집을 선택했을 때 얻는 돈의 최대값
#  이었다면, 상향식일 때는 for 문을 돌면서 cache[i] 에 0부터 i 까지의 집을 되는 대로 털었을때 얻는 돈의 최대값 입니다.
#  방향이 바뀌었죠?
#
# 2. 0번째 집을 털었느냐 안 털었느냐로 구분해야 한다는 것도 깨닫는데 오래 걸립니다.
#   그 전까지 시도해 본 방법은 다음과 같습니다:
#   * bool 변수에 0번째 인덱스가 들어있는지 여부를 저장하고 cache[i-2] + money[i] 를 할 때 마다
#     반전한다. (완전히 틀린 답입니다)
#   * cache 할 때 (최대값, 0번째 요소가 들었는지 여부) 를 갖고 있는 튜플을 저장하고
#     마지막에 튜플[1] 을 참조해서 의사결정한다. 이 방법은 제가 생각하기엔 완벽한데, 20개 중 3개의
#     케이스에서 오답을 냅니다. 아직도 왜 잘못됬는지 모르겠습니다.
#   * cache 와 cache2 를 만들고 각각 for 문을 1번씩 총 2번 돈다. 결국 이게 답입니다. (물론 한 for 문에서 cache 와
#     cache2 를 조작하고 cache2 만 한 번 더 만져줘도 되는 거 같네요) 이 모든 비효율이 집 들이 "원형" 이기 때문입니다.
#



def solution(money):
    '''
    0 번을 골랐을 때 맨 끝 집도 고를 수 있는 로직이라 정확도가 낮음.
    '''
    cache = [money[0], money[0]] # 0번째 요소를 고르고 시작한 경우
    cache2 = [0, money[1]] # 0번째 요소를 고르지 않고 시작한 경우

    for i in range(2, len(money)-1):
        cache.append(max(cache[i-2] + money[i], cache[i-1]))

    for i in range(2, len(money)):
        cache2.append(max(cache2[i-2] + money[i], cache2[i-1]))

    return max(cache[-1], cache2[-1])


print(solution([2, 2, 3, 1]))
# print(solution([1, 9, 1]))
# print(solution([1, 8, 8]))
# print(solution([8, 1, 8]))
# print(solution([8, 8, 8]))
# print(solution([8, 8, 8, 8]))
# print(solution([8, 8, 8, 8, 8]))
# print(solution([1, 90, 3, 1, 90, 2]))
# print(solution([1, 90, 3, 1, 90, 2]))
# print(solution([0, 90, 3, 1, 90, 2]))
# print(solution([0, 90, 0, 0, 90, 2]))
# print(solution([0, 0, 90, 0, 90, 2]))
# print(solution([0, 0, 0, 0, 90, 90]))
# print(solution([0, 0, 0, 0, 180, 90]))
# print(solution([0, 0, 0, 180, 0, 90]))
# print(solution([180, 0, 0, 180, 0, 90]))
# print(solution([180, 0, 0, 181, 0, 90]))
print(solution([0, 90, 0, 181, 0, 90]))
print(solution([0, 90, 0, 181, 0, 90]))
# print(solution([0, 0, 3, 1, 90, 2])) # 정답은 93
# print(solution([9, 3, 9, 3, 1]))
# print(solution([1, 2, 3, 4, 5, 6, 7, 8, 9])) # 정답은 24. 3 5 7 9 선택. 내 함수는 25 cache[-2] < cache[-1]
# print(solution([9, 8, 7, 6, 5, 4, 3, 2, 1])) # 정답은 24. 3 5 7 9 선택. 내 함수는 25 cache[-2] < cache[-1]
# print(solution([1, 2, 3, 4, 5, 6, 7, 8, 10, 9])) # 정답 29. cache[-2] < cache[-1]
